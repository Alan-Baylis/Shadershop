Architecture
  Move "builtIn" into its own file.
  Move "combiners" into their own thing. Think of better name.


Misc
  Figure out how React context works
  Do something better than util.safeInv
  Tune mousewheel zooming
  Delete key
  Undo
  Duplicate
  Check that you don't create dependency loops
  Need to listen for scroll events on Scrollers and refresh





Plot
  Plot wants to be configurable: at least which axes correspond to which coordinates in domain/range





Outline Stuff
  Break out "Inspector"
  Create definition button / right click item - create by abstracting
  Show transform numbers when they're not identity?


Inspector
  Highlight transform numbers when hovering the control point
  Show transform numbers next to control point
  Scrub transform numbers in inspector?


Palette
  Insert button
  Anything can be dragged into the outline to put it in a specific place
  Maybe
    + insert buttons in outline like before
  Some way to delete definitions






Get Grid using better Plot API

Get ShaderOverlayView using better Plot API
  Be able to use any coordinates (right now d0, r0 is hardcoded for cartesian, and d0, d1, r0 is hardcoded for colorMap)















Priority
  projections, to make the 2D noise example easier
    need y-x cartesian
    need to be able to see/move the projection
  something better than inspector
    text fields on control points would work
    should fix how control points show up on graph if they're not "in" the projection (e.g. for a domain-rotated 2D function on a cartesian slice.)
  need duplicate
    would be nice to have drag multiple, but not needed
  flexible color scale for colorMap
  performance
    send in selectedChildFn transforms as uniforms into shaders to make dragging control points faster



























In progress cartesian program refactor:




Glod = require("./plot/glod")


R.create "ShaderOverlayView",

  initializeGlod: ->
    @glod = new Glod()
    canvas = @getDOMNode()
    @glod.canvas(canvas, {antialias: true})

    gl = @glod.gl()
    gl.enable(gl.SCISSOR_TEST)
    gl.lineWidth(1.25)

    bufferQuad(@glod)
    bufferCartesianSamples(@glod, 20000)

    @programs = {}

  sizeCanvas: ->
    canvas = @getDOMNode()
    rect = canvas.getBoundingClientRect()
    if canvas.width != rect.width or canvas.height != rect.height
      canvas.width = rect.width
      canvas.height = rect.height

  draw: ->
    canvas = @getDOMNode()

    usedPrograms = {}

    shaderEls = document.querySelectorAll(".Shader")
    for shaderEl in shaderEls
      continue unless shaderEl.isOnScreen()

      rect = shaderEl.getBoundingClientRect()
      clippingRect = shaderEl.getClippingRect()

      continue if clippingRect.height <= 0 or clippingRect.width <= 0

      setViewport(@glod, rect, clippingRect)

      shaderView = shaderEl.dataFor
      exprs = shaderView.exprs
      plot = shaderView.plot
      bounds = plot.getBounds(rect.width, rect.height)

      numSamples = rect.width / config.resolution

      for expr in exprs
        name = plot.type + "," + expr.exprString
        unless @programs[name]

          if plot.type == "cartesian"
            createCartesianProgram(@glod, name, expr.exprString)
          else if plot.type == "colorMap"
            createColorMapProgram(@glod, name, expr.exprString)

          @programs[name] = true
        usedPrograms[name] = true

        if plot.type == "cartesian"
          drawCartesianProgram(@glod, name, expr.color, plot, rect.width, rect.height)
        else if plot.type == "colorMap"
          drawColorMapProgram(@glod, name, bounds)

    # Delete unused programs
    for own name, junk of @programs
      unless usedPrograms[name]
        delete @glod._programs[name]
        delete @programs[name]


  # ===========================================================================
  # Lifecycle
  # ===========================================================================

  handleResize: ->
    @sizeCanvas()
    @draw()

  componentDidMount: ->
    @initializeGlod()
    @sizeCanvas()
    window.addEventListener("resize", @handleResize)

  componentWillUnmount: ->
    window.removeEventListener("resize", @handleResize)

  # ===========================================================================
  # Render
  # ===========================================================================

  render: ->
    R.canvas {className: "ShaderOverlay"}






# =============================================================================
# Glod
# =============================================================================

# =============================================================================
# Utility
# =============================================================================

createProgramFromSrc = (glod, name, vertex, fragment) ->
  Glod.preprocessed[name] = {name, fragment, vertex}

  delete glod._programs[name]
  glod.createProgram(name)

setViewport = (glod, rect, clippingRect) ->
  gl = glod.gl()
  canvas = glod.canvas()

  x = rect.left
  y = canvas.height - rect.bottom
  w = rect.width
  h = rect.height

  sx = clippingRect.left
  sy = canvas.height - clippingRect.bottom
  sw = clippingRect.width
  sh = clippingRect.height

  gl.viewport(x, y, w, h)
  gl.scissor(sx, sy, sw, sh)

  glod.viewport_ = {x, y, w, h}



# =============================================================================
# VBOs
# =============================================================================

bufferQuad = (glod) ->
  glod
    .createVBO("quad")
    .uploadCCWQuad("quad")

bufferCartesianSamples = (glod, numSamples) ->
  samplesArray = []
  for i in [0..numSamples]
    samplesArray.push(i)

  if glod.hasVBO("samples")
    glod.deleteVBO("samples")

  glod
    .createVBO("samples")
    .bufferDataStatic("samples", new Float32Array(samplesArray))


# =============================================================================
# Shader Programs
# =============================================================================

createCartesianProgram = (glod, name, expr) ->

  vecType = util.glslVectorType(config.dimensions)
  matType = util.glslMatrixType(config.dimensions)

  vertex = """
  precision highp float;
  precision highp int;

  attribute float sample;

  uniform #{vecType} domainStart, domainStep;
  uniform #{matType} cameraTransform;
  uniform #{vecType} cameraTranslate;


  void main() {
    #{vecType} inputVal, outputVal;
    inputVal = domainStart + domainStep * sample;
    #{vecType} x = inputVal; // TODO: make inputVal the new x
    outputVal = #{expr};

    #{vecType} position;
    position = cameraTransform * outputVal + cameraTranslate;
    gl_Position = vec4(position.x, position.y, 0., 1.);
  }
  """

  fragment = """
  precision highp float;
  precision highp int;

  uniform vec4 color;

  void main() {
    gl_FragColor = color;
  }
  """

  createProgramFromSrc(glod, name, vertex, fragment)

drawCartesianProgram = (glod, name, color, plot, width, height) ->
  pixelSize = plot.getPixelSize(width, height)
  center = {
    domain: plot.domainCenter
    range:  plot.rangeCenter
  }
  dimensions = plot.getDimensions()

  if dimensions[0].space == "domain"
    domainSizeInPixels = width
    coord = dimensions[0].coord
  else if dimensions[1].space == "domain"
    domainSizeInPixels = height
    coord = dimensions[1].coord
  else
    console.error "Cannot draw cartesian without a domain dimension"

  domainCenter = center.domain
  domainOffset = util.constructVector(config.dimensions, 0)
  domainOffset[coord] = -(domainSizeInPixels / 2) * pixelSize
  domainStart = util.vector.add(domainStart, domainOffset)

  domainStep = util.constructVector(config.dimensions, 0)
  domainStep[coord] = pixelSize * config.resolution

  numSamples = domainSizeInPixels / config.resolution







  glod.begin(name)

  glod.pack("samples", "sample")

  glod.valuev("color", color)



  glod.value("xMin", bounds.xMin)
  glod.value("xMax", bounds.xMax)
  glod.value("yMin", bounds.yMin)
  glod.value("yMax", bounds.yMax)

  glod.value("numSamples", numSamples)

  glod.ready().lineStrip().drawArrays(0, numSamples)

  glod.end()



createColorMapProgram = (glod, name, expr) ->

  vertex = """
  precision highp float;
  precision highp int;

  attribute vec4 position;

  void main() {
    gl_Position = position;
  }
  """

  # TODO: Needs proper support for config.dimensions
  fragment = """
  precision highp float;
  precision highp int;

  uniform float screenXMin, screenXMax, screenYMin, screenYMax;

  uniform float xMin;
  uniform float xMax;
  uniform float yMin;
  uniform float yMax;

  float lerp(float x, float dMin, float dMax, float rMin, float rMax) {
    float ratio = (x - dMin) / (dMax - dMin);
    return ratio * (rMax - rMin) + rMin;
  }

  void main() {
    vec4 x = vec4(
      lerp(gl_FragCoord.x, screenXMin, screenXMax, xMin, xMax),
      lerp(gl_FragCoord.y, screenYMin, screenYMax, yMin, yMax),
      0.,
      0.
    );
    vec4 y = #{expr};

    float value = y.x;
    float normvalue = abs(value);
    vec3 color;
    if (value > 0.) {
      color = mix(vec3(1., 1., 1.), vec3(#{config.colorMapPositive}), normvalue);
    } else {
      color = mix(vec3(1., 1., 1.), vec3(#{config.colorMapNegative}), normvalue);
    }

    gl_FragColor = vec4(color, 1.);
  }
  """

  createProgramFromSrc(glod, name, vertex, fragment)

drawColorMapProgram = (glod, name, bounds) ->
  canvas = glod.canvas()

  glod.begin(name)

  glod.pack("quad", "position")

  glod.value("screenXMin", glod.viewport_.x)
  glod.value("screenXMax", glod.viewport_.x + glod.viewport_.w)
  glod.value("screenYMin", glod.viewport_.y)
  glod.value("screenYMax", glod.viewport_.y + glod.viewport_.h)

  glod.value("xMin", bounds.xMin)
  glod.value("xMax", bounds.xMax)
  glod.value("yMin", bounds.yMin)
  glod.value("yMax", bounds.yMax)

  glod.ready().triangles().drawArrays(0, 6)

  glod.end()






